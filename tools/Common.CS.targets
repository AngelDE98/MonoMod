<?xml version="1.0" encoding="utf-8"?>
<Project>

  <!-- C#-specific targets -->
  
  <!-- Roslyn references -->
  <ItemGroup>
    <PackageReference Include="Microsoft.Net.Compilers.Toolset" Version="$(RoslynVersion)" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp.CodeStyle" Version="$(RoslynVersion)">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <PropertyGroup>
    <CoreCompileDependsOn>
      EnsureSupportedMSBuildVersion;
      $(CoreCompileDependsOn);
    </CoreCompileDependsOn>
  </PropertyGroup>

  <Target Name="EnsureSupportedMSBuildVersion"
          BeforeTargets="CoreCompile"
          Condition="'$(MSBuildRequiredVersion)' != ''">
    <Error ContinueOnError="false" Text="MSBuild version is too old to build this project; currently $(MSBuildVersion), needs at least $(MSBuildRequiredVersion)"
           Condition="$([MSBuild]::VersionLessThan('$(MSBuildVersion)', '$(MSBuildRequiredVersion)'))" />
  </Target>

  <!-- Backports reference -->
  <ItemGroup Condition="'$(MMReferenceBackports)' == 'true'">
    <ProjectReference Include="$(MMSourcePath)MonoMod.Backports\MonoMod.Backports.csproj" />
    <!-- Shared source files -->
    <Compile Include="$(MMCommonPath)Shared\**\*.cs" Condition="'$(MMSharedSourceFiles)' == 'true'">
      <Link>Shared/%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Compile>
    <!-- Source Generator reference -->
    <!-- This is dependent on ReferenceBackports because the source generator will assume the presence of Backports -->
    <ProjectReference Include="$(MMSourcePath)MonoMod.SourceGen.Internal\MonoMod.SourceGen.Internal.csproj" Condition="'$(MMUseSourceGen)' != 'false'">
      <Reference>false</Reference>
      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
      <OutputItemType>Analyzer</OutputItemType>
      <Private>false</Private>
      <PrivateAssets>all</PrivateAssets>
      <SetTargetFramework>TargetFramework=netstandard2.0</SetTargetFramework>
      <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
      <Pack>false</Pack>
    </ProjectReference>
    <CompilerVisibleProperty Include="AssemblyName" />
    <CompilerVisibleProperty Include="Version" />
    <CompilerVisibleProperty Include="RootNamespace" />
  </ItemGroup>
  
  <!-- ILHelpers reference -->
  <ItemGroup Condition="'$(MMReferenceILHelpers)' == 'true'">
    <Compile Include="$(MMCommonPath)UnsafeAlias.cs" Condition="'$(MMIncludeUnsafeAlias)' == 'true'">
      <Link>Shared/%(Filename)%(Extension)</Link>
    </Compile>
    <ProjectReference Include="$(MMSourcePath)MonoMod.ILHelpers\MonoMod.ILHelpers.ilproj">
      <Aliases Condition="'$(MMIncludeUnsafeAlias)' == 'true'">ilhelpers</Aliases>
    </ProjectReference>
  </ItemGroup>
  
  <!-- MonoMod.Utils reference -->
  <ItemGroup Condition="'$(MMReferenceUtils)' == 'true'">
    <ProjectReference Include="$(MMSourcePath)MonoMod.Utils\MonoMod.Utils.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <_TFMIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)'))</_TFMIdentifier>
  </PropertyGroup>

  <ItemGroup Condition="'$(_TFMIdentifier)' == '.NETFramework'">
    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>
    
  <Choose>
    <When Condition="'$(_TFMIdentifier)' == '.NETCoreApp'">
      <!-- .NET Core -->
      <PropertyGroup>
        <DefineConstants>$(DefineConstants)</DefineConstants>
        <DefineConstants>CECIL0_11;$(DefineConstants)</DefineConstants>
        <CecilVersion Condition="'$(CecilVersion)' == ''">$(NewCecilVersion)</CecilVersion>
        <NETShimVersion>4.*</NETShimVersion>
      </PropertyGroup>

      <ItemGroup>
        <!-- For Core 2.1, we need this to make sure it doesn't include the shim assemblies in the package -->
        <PackageReference Update="Microsoft.NETCore.App" Pack="false" />
      </ItemGroup>
      
      <!-- These are also required when targeting .NET Standard 2.0 to resolve a version conflict with Mono.Cecil's deps. ->
      <ItemGroup>
        <PackageReference Include="System.Reflection.TypeExtensions" Version="$(NETShimVersion)" />
        <PackageReference Include="System.Collections.NonGeneric" Version="$(NETShimVersion)" />
        <PackageReference Include="System.ComponentModel.TypeConverter" Version="$(NETShimVersion)" />
        <PackageReference Include="System.IO.FileSystem.Primitives" Version="$(NETShimVersion)" />
      </ItemGroup>
      <!- This could be made optional at compile-time, but it's preferred to check for availability at runtime. ->
      <ItemGroup>
        <PackageReference Include="System.Reflection.Emit.Lightweight" Version="$(NETShimVersion)" />
        <PackageReference Include="System.Reflection.Emit.ILGeneration" Version="$(NETShimVersion)" />
      </ItemGroup>
      --> <!-- These are commented out for .NET Core because I'm pretty sure they're not really needed -->
    </When>
    
    <When Condition="'$(_TFMIdentifier)' == '.NETStandard'">
      <!-- .NET Standard -->
      <PropertyGroup>
        <DefineConstants>NETSTANDARD;$(DefineConstants)</DefineConstants>
        <DefineConstants>CECIL0_11;$(DefineConstants)</DefineConstants>
        <CecilVersion Condition="'$(CecilVersion)' == ''">$(NewCecilVersion)</CecilVersion>
        <NETShimVersion>4.*</NETShimVersion>
      </PropertyGroup>
      <!-- These are also required when targeting .NET Standard 2.0 to resolve a version conflict with Mono.Cecil's deps. -->
      <ItemGroup>
        <PackageReference Include="System.Reflection.TypeExtensions" Version="$(NETShimVersion)" />
        <PackageReference Include="System.Collections.NonGeneric" Version="$(NETShimVersion)" />
        <PackageReference Include="System.ComponentModel.TypeConverter" Version="$(NETShimVersion)" />
        <PackageReference Include="System.IO.FileSystem.Primitives" Version="$(NETShimVersion)" />
      </ItemGroup>
      <!-- This could be made optional at compile-time, but it's preferred to check for availability at runtime. -->
      <ItemGroup>
        <PackageReference Include="System.Reflection.Emit.Lightweight" Version="$(NETShimVersion)" />
        <PackageReference Include="System.Reflection.Emit.ILGeneration" Version="$(NETShimVersion)" />
      </ItemGroup>
    </When>
    
    <When Condition="'$(TargetFramework)' != 'net35'">
      <!-- .NET Framework 4.0+ -->
      <PropertyGroup>
        <DefineConstants>NETFRAMEWORK4;$(DefineConstants)</DefineConstants>
        <DefineConstants>CECIL0_11;$(DefineConstants)</DefineConstants>
        <CecilVersion Condition="'$(CecilVersion)' == ''">$(NewCecilVersion)</CecilVersion>
      </PropertyGroup>
      <ItemGroup>
        <!-- <Reference Include="mscorlib" /> -->
        <Reference Include="System" />
      </ItemGroup>
    </When>
    
    <When Condition="'$(TargetFramework)' == 'net35'">
      <!-- .NET Framework 3.5 -->
      <PropertyGroup>
        <DefineConstants>NETFRAMEWORK3;$(DefineConstants)</DefineConstants>
        <DefineConstants>CECIL0_10;$(DefineConstants)</DefineConstants>
        <CecilVersion Condition="'$(CecilVersion)' == ''">$(OldCecilVersion)</CecilVersion>
      </PropertyGroup>
      <ItemGroup>
        <!-- <Reference Include="mscorlib" /> -->
        <Reference Include="System" />
      </ItemGroup>
    </When>
  </Choose>

  <ItemGroup>
    <PackageReference Update="Mono.Cecil" Version="$(CecilVersion)" />
  </ItemGroup>
  
  <!-- Conditional Source Generators a.k.a. Source Generators whose output is checked in to git -->
  <Target Name="_TestFilesForChange" Returns="$(HaveFilesChanged)">
    <!-- files in prop FilesToTest -->
    <ItemGroup>
      <_FilesToTest Include="$(FilesToTest)" />
    </ItemGroup>
    <!-- Invoke once for all of them to test if they've changed -->
    <Exec Command="git diff --quiet --exit-code -- @(_FilesToTest->'&quot;%(Identity)&quot;',' ')"
          IgnoreStandardErrorWarningFormat="true"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" ItemName="_GitExitCodes"/>
    </Exec>
    <PropertyGroup>
      <HaveFilesChanged>false</HaveFilesChanged>
      <HaveFilesChanged Condition="'%(_GitExitCodes.Identity)' == '1'">true</HaveFilesChanged>
    </PropertyGroup>
  </Target>
  
  <Target Name="_ComputeConditionalGeneratorsStatus">
    <!-- TODO: also check if current project is newer than emitted files -->
    
    <ItemGroup>
      <ConditionalGeneratorReference>
        <_PropName>$([System.String]::Copy('%(Identity)').Replace('.','_'))</_PropName>
        <_ShouldInclude>false</_ShouldInclude>
        <_ShouldInclude Condition="!Exists('$(MMGeneratedSourcesDir)')">true</_ShouldInclude>
        <_ShouldInclude Condition="!Exists('$(MMGeneratedSourcesDir)%(Identity)\')">true</_ShouldInclude>
        <_ShouldInclude Condition="!Exists('$(MMGeneratedSourcesDir)%(Identity)\$(TargetFramework)\')">true</_ShouldInclude>
        <_InvokeProjectFile>$(MSBuildProjectFile)</_InvokeProjectFile>
      </ConditionalGeneratorReference>
    </ItemGroup>
    
    <!-- Invoke _TestFilesForChange to filter by whether they should be processed -->
    <MSBuild Projects="%(_InvokeProjectFile)"
             Targets="_TestFilesForChange"
             Condition="'%(ConditionalGeneratorReference._ShouldInclude)' != 'true' and '%(IncludeIfChanged)' != ''"
             Properties="FilesToTest=%(IncludeIfChanged)">
      <Output TaskParameter="TargetOutputs" PropertyName="_cgr%(_PropName)_ShouldInclude" />
    </MSBuild>

    <ItemGroup>
      <ConditionalGeneratorReference>
        <_ShouldInclude Condition="'$(_cgr%(_PropName)_ShouldInclude)' == 'true'">true</_ShouldInclude>
      </ConditionalGeneratorReference>
    </ItemGroup>
  </Target>

  <Target Name="_IncludeConditionalGenerators" DependsOnTargets="_ComputeConditionalGeneratorsStatus">

    <PropertyGroup>
      <_IncludingAnyConditionalGenerators>false</_IncludingAnyConditionalGenerators>
      <_IncludingAnyConditionalGenerators Condition="'%(ConditionalGeneratorReference._ShouldInclude)' == 'true'">true</_IncludingAnyConditionalGenerators>
    </PropertyGroup>

    <ItemGroup>
      <_IncludedConditionalGenerators Include="@(ConditionalGeneratorReference)"
                        Condition="'%(ConditionalGeneratorReference._ShouldInclude)' == 'true'" />
      <PackageReference Include="@(_IncludedConditionalGenerators)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(_IncludingAnyConditionalGenerators)' == 'true'">
      <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
      <CompilerGeneratedFilesOutputPath>$(IntermediateOutputPath)/generated</CompilerGeneratedFilesOutputPath>
    </PropertyGroup>
    
    <Delete Files="$(MMGeneratedSourcesDir)%(_IncludedConditionalGenerators.Identity)\" />
    
  </Target>
  
  <Target Name="IncludeConditionalGenerators"
          BeforeTargets="CoreCompile;CollectPackageReferences"
          DependsOnTargets="_ComputeConditionalGeneratorsStatus;_IncludeConditionalGenerators">
  </Target>
    
  <ItemGroup Condition="'$(TargetFramework)' != ''">
    <Compile Remove="$(MMGeneratedSourcesDir)\**\*" />
    <None Include="$(MMGeneratedSourcesDir)\**\*" />
    <Compile Include="$(MMGeneratedSourcesDir)\*\$(TargetFramework)\**\*" />
    <None Remove="@(Compile)" />
  </ItemGroup>

  <Target Name="CopyConditionalGeneratorCodeToSrcDir"
          Condition="'$(_IncludingAnyConditionalGenerators)' == 'true'"
          AfterTargets="CoreCompile">
          
    <MakeDir Directories="$(MMGeneratedSourcesDir)%(_IncludedConditionalGenerators.Identity)\" />
    
    <ItemGroup>
      <_GeneratedSourceFiles Include="$(CompilerGeneratedFilesOutputPath)\%(_IncludedConditionalGenerators.Identity)\**\*">
        <CondRefName>%(_IncludedConditionalGenerators.Identity)</CondRefName>
      </_GeneratedSourceFiles>
    </ItemGroup>
    
    <Copy SourceFiles="@(_GeneratedSourceFiles)"
          DestinationFiles="$(MMGeneratedSourcesDir)%(CondRefName)\$(TargetFramework)\%(RecursiveDir)%(Filename)%(Extension)" />
    
  </Target>

</Project>