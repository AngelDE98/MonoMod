// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{

	/// <content>
	/// Contains extern methods from "KERNEL32.dll".
	/// </content>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.63-beta+89e7e0c43f")]
	internal static partial class Interop
	{
		/// <inheritdoc cref="GetSystemInfo(winmdroot.System.SystemInformation.SYSTEM_INFO*)"/>
		internal static unsafe void GetSystemInfo(out winmdroot.System.SystemInformation.SYSTEM_INFO lpSystemInfo)
		{
			fixed (winmdroot.System.SystemInformation.SYSTEM_INFO* lpSystemInfoLocal = &lpSystemInfo)
			{
				Interop.GetSystemInfo(lpSystemInfoLocal);
			}
		}

		/// <summary>Retrieves information about the current system.</summary>
		/// <param name="lpSystemInfo">
		/// <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure that receives the information.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe void GetSystemInfo(winmdroot.System.SystemInformation.SYSTEM_INFO* lpSystemInfo);

		/// <summary>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process.</summary>
		/// <param name="lpAddress">
		/// <para>The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function. If this parameter is <b>NULL</b>, the system determines where to allocate the region. If this address is within an enclave that you have not initialized by calling <a href="https://docs.microsoft.com/windows/desktop/api/enclaveapi/nf-enclaveapi-initializeenclave">InitializeEnclave</a>, <b>VirtualAlloc</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model. If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwSize">
		/// <para>The size of the region, in bytes. If the <i>lpAddress</i> parameter is <b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="flAllocationType"></param>
		/// <param name="flProtect">
		/// <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href="https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualalloc">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe void* VirtualAlloc([Optional] void* lpAddress, nuint dwSize, winmdroot.System.Memory.VIRTUAL_ALLOCATION_TYPE flAllocationType, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS flProtect);

		/// <inheritdoc cref="VirtualProtect(void*, nuint, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS*)"/>
		internal static unsafe winmdroot.Foundation.BOOL VirtualProtect(void* lpAddress, nuint dwSize, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS flNewProtect, out winmdroot.System.Memory.PAGE_PROTECTION_FLAGS lpflOldProtect)
		{
			fixed (winmdroot.System.Memory.PAGE_PROTECTION_FLAGS* lpflOldProtectLocal = &lpflOldProtect)
			{
				winmdroot.Foundation.BOOL __result = Interop.VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtectLocal);
				return __result;
			}
		}

		/// <summary>Changes the protection on a region of committed pages in the virtual address space of the calling process.</summary>
		/// <param name="lpAddress">
		/// <para>The address of the starting page of the region of pages whose access protection attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwSize">
		/// <para>The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="flNewProtect">
		/// <para>The memory protection option. This parameter can be one of the <a href="https://docs.microsoft.com/windows/desktop/Memory/memory-protection-constants">memory protection constants</a>. For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a>, <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffileex">MapViewOfFileEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-mapviewoffileexnuma">MapViewOfFileExNuma</a>).</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpflOldProtect">
		/// <para>A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualprotect">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOL VirtualProtect(void* lpAddress, nuint dwSize, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS flNewProtect, winmdroot.System.Memory.PAGE_PROTECTION_FLAGS* lpflOldProtect);

		/// <summary>Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.</summary>
		/// <param name="lpAddress">
		/// <para>A pointer to the base address of the region of pages to be freed.</para>
		/// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be the base address returned by the <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function when the region of pages is reserved.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwSize">
		/// <para>The size of the region of memory to be freed, in bytes.</para>
		/// <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>. If the <i>dwFreeType</i> parameter is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <c>(lpAddress+dwSize)</c>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by <b>VirtualAlloc</b>. After that, the entire region is in the reserved state.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwFreeType"></param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//memoryapi/nf-memoryapi-virtualfree">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOL VirtualFree(void* lpAddress, nuint dwSize, winmdroot.System.Memory.VIRTUAL_FREE_TYPE dwFreeType);

		/// <summary>Closes an open object handle.</summary>
		/// <param name="hObject">A valid handle to an open object.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-closehandle">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.BOOL CloseHandle(winmdroot.Foundation.HANDLE hObject);

		/// <summary>Retrieves a pseudo handle for the current process.</summary>
		/// <returns>The return value is a pseudo handle to the current process.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-getcurrentprocess">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.Foundation.HANDLE GetCurrentProcess();

		/// <summary>Flushes the instruction cache for the specified process.</summary>
		/// <param name="hProcess">A handle to a process whose instruction cache is to be flushed.</param>
		/// <param name="lpBaseAddress">A pointer to the base of the region to be flushed. This parameter can be <b>NULL</b>.</param>
		/// <param name="dwSize">The size of the region to be flushed if the <i>lpBaseAddress</i> parameter is not <b>NULL</b>, in bytes.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//processthreadsapi/nf-processthreadsapi-flushinstructioncache">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOL FlushInstructionCache(winmdroot.Foundation.HANDLE hProcess, [Optional] void* lpBaseAddress, nuint dwSize);
	}
}
