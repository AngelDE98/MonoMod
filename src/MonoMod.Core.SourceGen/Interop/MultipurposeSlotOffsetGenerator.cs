using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace MonoMod.Core.SourceGen.Interop
{
    [Generator]
    public class MultipurposeSlotOffsetGenerator : IIncrementalGenerator {
        private const string AttributeName = "MonoMod.Core.Interop.Attributes.MultipurposeSlotOffsetTableAttribute";

        private record GenerationInfo(IMethodSymbol Method, SyntaxTokenList Modifiers, int Depth, INamedTypeSymbol HelperType);

        public void Initialize(IncrementalGeneratorInitializationContext context) {

            var fields = context.SyntaxProvider
                .CreateSyntaxProvider(IsTargetField, GetSemanticTarget)
                .Where(static m => m is not null);

            var fieldsWithCompilation = context.CompilationProvider.Combine(fields.Collect());

            context.RegisterSourceOutput(fieldsWithCompilation,
                static (spc, tuple) => Execute(spc, tuple.Left, tuple.Right!));
        }

        private static bool IsTargetField(SyntaxNode node, CancellationToken cancellationToken)
            => node is MethodDeclarationSyntax s && s.AttributeLists.Count > 0;

        private static GenerationInfo? GetSemanticTarget(GeneratorSyntaxContext ctx, CancellationToken cancellationToken) {
            var methodSyntax = (MethodDeclarationSyntax) ctx.Node;

            foreach (var attrList in methodSyntax.AttributeLists) {
                foreach (var attr in attrList.Attributes) {
                    if (ctx.SemanticModel.GetSymbolInfo(attr, cancellationToken).Symbol is not IMethodSymbol attrSym) {
                        // we couldn't get the model for the attribute, for some reason
                        continue;
                    }

                    var type = attrSym.ContainingType;
                    if (type.ToDisplayString() == AttributeName) {
                        if (attr.ArgumentList is not { } attrArgs) {
                            // what?
                            Console.WriteLine("[SRC] Arg list doesn't exist");
                            continue;
                        }

                        if (attrArgs.Arguments.Count < 2) {
                            // what?
                            Console.WriteLine("[SRC] Arg list too short");
                            continue;
                        }

                        var firstArg = attrArgs.Arguments[0];
                        var argValue = ctx.SemanticModel.GetConstantValue(firstArg.Expression, cancellationToken);
                        if (!argValue.HasValue) {
                            continue;
                        }
                        if (argValue.Value is not int num) {
                            // what?
                            continue;
                        }

                        var secondArg = attrArgs.Arguments[1];
                        if (secondArg.Expression is not TypeOfExpressionSyntax typeOf) {
                            // what?
                            continue;
                        }

                        if (ctx.SemanticModel.GetDeclaredSymbol(methodSyntax, cancellationToken) is not IMethodSymbol methSym) {
                            Console.WriteLine($"[SRC] No method ({methodSyntax} ({methodSyntax.GetType()}))");
                            // we couldn't get the model for the field, for some reason
                            continue;
                        }

                        if (ctx.SemanticModel.GetSymbolInfo(typeOf.Type, cancellationToken).Symbol is not INamedTypeSymbol helperType) {
                            Console.WriteLine($"[SRC] No helper type");
                            continue;
                        }

                        return new(methSym, methodSyntax.Modifiers, num, helperType);
                    }
                }
            }

            return null;
        }

        private static void Execute(SourceProductionContext spc, Compilation compilation, ImmutableArray<GenerationInfo> fields) {
            if (fields.IsDefaultOrEmpty) {
                return;
            }

            var sb = new StringBuilder();

            foreach (var field in fields) {
                BuildSourceFor(sb, compilation, field, out var fieldName);
                spc.AddSource($"MpSlot_{fieldName}.g.cs", sb.ToString());
                sb.Clear();
            }
        }

        private static void BuildSourceFor(StringBuilder builder, Compilation compilation, GenerationInfo info, out string fieldName) {
            builder.Append("// <auto-generated />");

            var methodSymbol = info.Method;
            var helperSymbol = info.HelperType;

            var helperName = helperSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var containingTypes = new List<INamedTypeSymbol>();
            string? namespaceName;
            {
                INamedTypeSymbol? outerType = null;
                ISymbol currentSym = methodSymbol;
                while (currentSym.ContainingType is not null) {
                    outerType = currentSym.ContainingType;
                    containingTypes.Add(outerType);
                    currentSym = outerType;
                }

                var ns = outerType?.ContainingNamespace;
                if (ns is null) {
                    namespaceName = null;
                } else {
                    namespaceName = ns.ToDisplayString();
                }
            }

            containingTypes.Reverse();

            if (namespaceName != null) {
                builder.Append($@"
namespace {namespaceName} {{");
            }

            foreach (var type in containingTypes) {
                var isRec = type.IsRecord;
                var isStruct = type.IsValueType;
                var isRef = type.IsReferenceType;

                builder.Append($@"
    partial {(isRec ? "record" : "")}{(isRef && !isRec ? "class" : "")} {(isStruct ? "struct" : "")} {type.Name} {{");
            }

            builder.Append($@"
        ");
            foreach (var mod in info.Modifiers) {
                builder.Append(mod.Text).Append(' ');
            }
            builder.Append($@"byte[] {methodSymbol.Name}() => new byte[] {{
            ");

            // https://github.com/dotnet/runtime/blob/v6.0.5/src/coreclr/vm/methodtable.cpp#L318
            var maxVal = 1u << info.Depth;
            for (var mask = 0u; mask < maxVal; mask++) {
                var raw = PopCount(mask);
                var index = (((mask & 3) == 2) && (raw == 1)) ? 0 : raw;

                if (index == 0) {
                    builder.Append($"{helperName}.OffsetOfMp1(), ");
                } else if (index == 1) {
                    builder.Append($"{helperName}.OffsetOfMp2(), ");
                } else {
                    builder.Append($"{helperName}.RegularOffset({index}), ");
                }
            }

            builder.Append($@"
        }};");

            for (var i = 0; i < containingTypes.Count; i++) {
                builder.Append($@"
    }}");
            }

            if (namespaceName != null) {
                builder.Append($@"
}}");
            }

            fieldName = $"{namespaceName}.{string.Join(".", containingTypes.Select(t => t.Name))}.{methodSymbol.Name}";
        }

        private static int PopCount(uint value) {
            const uint c1 = 0x_55555555u;
            const uint c2 = 0x_33333333u;
            const uint c3 = 0x_0F0F0F0Fu;
            const uint c4 = 0x_01010101u;

            value -= (value >> 1) & c1;
            value = (value & c2) + ((value >> 2) & c2);
            value = (((value + (value >> 4)) & c3) * c4) >> 24;

            return (int) value;
        }
    }
}
